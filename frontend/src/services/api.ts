/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * Issue Tracker API
 * OneSAAS Issue Tracker API - OpenAPI 3.0 specification
 * OpenAPI spec version: 1.0.0
 */
import {
    useMutation,
    useQuery
} from '@tanstack/react-query';
import type {
    DataTag,
    DefinedInitialDataOptions,
    DefinedUseQueryResult,
    MutationFunction,
    QueryClient,
    QueryFunction,
    QueryKey,
    UndefinedInitialDataOptions,
    UseMutationOptions,
    UseMutationResult,
    UseQueryOptions,
    UseQueryResult
} from '@tanstack/react-query';

import { customInstance } from './axiosInstance';
/**
 * Current status
 */
export type IssueResponseDtoStatus = typeof IssueResponseDtoStatus[keyof typeof IssueResponseDtoStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IssueResponseDtoStatus = {
    open: 'open',
    in_progress: 'in_progress',
    closed: 'closed',
} as const;

export interface IssueResponseDto {
    /** Unique identifier */
    id: string;
    /** Issue title */
    title: string;
    /** Issue description */
    description: string;
    /** Current status */
    status: IssueResponseDtoStatus;
    /** Creator user ID */
    createdBy: string;
    /** Assigned user ID */
    assignedTo?: string;
    /** Creation timestamp */
    createdAt: string;
    /** Last update timestamp */
    updatedAt: string;
}

/**
 * Current status of the issue
 */
export type CreateIssueDtoStatus = typeof CreateIssueDtoStatus[keyof typeof CreateIssueDtoStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateIssueDtoStatus = {
    open: 'open',
    in_progress: 'in_progress',
    closed: 'closed',
} as const;

export interface CreateIssueDto {
    /**
     * Issue title
     * @minLength 3
     * @maxLength 120
     */
    title: string;
    /** Detailed description of the issue */
    description: string;
    /** Current status of the issue */
    status?: CreateIssueDtoStatus;
    /** UUID of the user who created the issue */
    createdBy: string;
    /** UUID of the user assigned to this issue */
    assignedTo?: string;
}

/**
 * Current status of the issue
 */
export type UpdateIssueDtoStatus = typeof UpdateIssueDtoStatus[keyof typeof UpdateIssueDtoStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateIssueDtoStatus = {
    open: 'open',
    in_progress: 'in_progress',
    closed: 'closed',
} as const;

export interface UpdateIssueDto {
    /**
     * Issue title
     * @minLength 3
     * @maxLength 120
     */
    title?: string;
    /** Detailed description of the issue */
    description?: string;
    /** Current status of the issue */
    status?: UpdateIssueDtoStatus;
    /** UUID of the user assigned to this issue */
    assignedTo?: string;
}

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Retrieve a list of all issues
 * @summary Get all issues
 */
export const issuesControllerFindAll = (

    options?: SecondParameter<typeof customInstance>, signal?: AbortSignal
) => {


    return customInstance<IssueResponseDto[]>(
        {
            url: `/issues`, method: 'GET', signal
        },
        options);
}




export const getIssuesControllerFindAllQueryKey = () => {
    return [
        `/issues`
    ] as const;
}


export const getIssuesControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof issuesControllerFindAll>>, TError = void>(options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof issuesControllerFindAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance> }
) => {

    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getIssuesControllerFindAllQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof issuesControllerFindAll>>> = ({ signal }) => issuesControllerFindAll(requestOptions, signal);





    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof issuesControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IssuesControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof issuesControllerFindAll>>>
export type IssuesControllerFindAllQueryError = void


export function useIssuesControllerFindAll<TData = Awaited<ReturnType<typeof issuesControllerFindAll>>, TError = void>(
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof issuesControllerFindAll>>, TError, TData>> & Pick<
            DefinedInitialDataOptions<
                Awaited<ReturnType<typeof issuesControllerFindAll>>,
                TError,
                Awaited<ReturnType<typeof issuesControllerFindAll>>
            >, 'initialData'
        >, request?: SecondParameter<typeof customInstance>
    }
    , queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIssuesControllerFindAll<TData = Awaited<ReturnType<typeof issuesControllerFindAll>>, TError = void>(
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof issuesControllerFindAll>>, TError, TData>> & Pick<
            UndefinedInitialDataOptions<
                Awaited<ReturnType<typeof issuesControllerFindAll>>,
                TError,
                Awaited<ReturnType<typeof issuesControllerFindAll>>
            >, 'initialData'
        >, request?: SecondParameter<typeof customInstance>
    }
    , queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIssuesControllerFindAll<TData = Awaited<ReturnType<typeof issuesControllerFindAll>>, TError = void>(
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof issuesControllerFindAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance> }
    , queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all issues
 */

export function useIssuesControllerFindAll<TData = Awaited<ReturnType<typeof issuesControllerFindAll>>, TError = void>(
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof issuesControllerFindAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance> }
    , queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

    const queryOptions = getIssuesControllerFindAllQueryOptions(options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}





/**
 * Create a new issue with the provided data
 * @summary Create new issue
 */
export const issuesControllerCreate = (
    createIssueDto: CreateIssueDto,
    options?: SecondParameter<typeof customInstance>, signal?: AbortSignal
) => {


    return customInstance<IssueResponseDto>(
        {
            url: `/issues`, method: 'POST',
            headers: { 'Content-Type': 'application/json', },
            data: createIssueDto, signal
        },
        options);
}



export const getIssuesControllerCreateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof issuesControllerCreate>>, TError, { data: CreateIssueDto }, TContext>, request?: SecondParameter<typeof customInstance> }
    ): UseMutationOptions<Awaited<ReturnType<typeof issuesControllerCreate>>, TError, { data: CreateIssueDto }, TContext> => {

    const mutationKey = ['issuesControllerCreate'];
    const { mutation: mutationOptions, request: requestOptions } = options ?
        options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
            options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey, }, request: undefined };




    const mutationFn: MutationFunction<Awaited<ReturnType<typeof issuesControllerCreate>>, { data: CreateIssueDto }> = (props) => {
        const { data } = props ?? {};

        return issuesControllerCreate(data, requestOptions)
    }




    return { mutationFn, ...mutationOptions }
}

export type IssuesControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof issuesControllerCreate>>>
export type IssuesControllerCreateMutationBody = CreateIssueDto
export type IssuesControllerCreateMutationError = void

/**
* @summary Create new issue
*/
export const useIssuesControllerCreate = <TError = void,
    TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof issuesControllerCreate>>, TError, { data: CreateIssueDto }, TContext>, request?: SecondParameter<typeof customInstance> }
        , queryClient?: QueryClient): UseMutationResult<
            Awaited<ReturnType<typeof issuesControllerCreate>>,
            TError,
            { data: CreateIssueDto },
            TContext
        > => {

    const mutationOptions = getIssuesControllerCreateMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
}

/**
 * Retrieve a specific issue by its UUID
 * @summary Get issue by ID
 */
export const issuesControllerFindOne = (
    id: string,
    options?: SecondParameter<typeof customInstance>, signal?: AbortSignal
) => {


    return customInstance<IssueResponseDto>(
        {
            url: `/issues/${id}`, method: 'GET', signal
        },
        options);
}




export const getIssuesControllerFindOneQueryKey = (id?: string,) => {
    return [
        `/issues/${id}`
    ] as const;
}


export const getIssuesControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof issuesControllerFindOne>>, TError = void>(id: string, options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof issuesControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof customInstance> }
) => {

    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getIssuesControllerFindOneQueryKey(id);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof issuesControllerFindOne>>> = ({ signal }) => issuesControllerFindOne(id, requestOptions, signal);





    return { queryKey, queryFn, enabled: !!(id), ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof issuesControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IssuesControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof issuesControllerFindOne>>>
export type IssuesControllerFindOneQueryError = void


export function useIssuesControllerFindOne<TData = Awaited<ReturnType<typeof issuesControllerFindOne>>, TError = void>(
    id: string, options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof issuesControllerFindOne>>, TError, TData>> & Pick<
            DefinedInitialDataOptions<
                Awaited<ReturnType<typeof issuesControllerFindOne>>,
                TError,
                Awaited<ReturnType<typeof issuesControllerFindOne>>
            >, 'initialData'
        >, request?: SecondParameter<typeof customInstance>
    }
    , queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIssuesControllerFindOne<TData = Awaited<ReturnType<typeof issuesControllerFindOne>>, TError = void>(
    id: string, options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof issuesControllerFindOne>>, TError, TData>> & Pick<
            UndefinedInitialDataOptions<
                Awaited<ReturnType<typeof issuesControllerFindOne>>,
                TError,
                Awaited<ReturnType<typeof issuesControllerFindOne>>
            >, 'initialData'
        >, request?: SecondParameter<typeof customInstance>
    }
    , queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIssuesControllerFindOne<TData = Awaited<ReturnType<typeof issuesControllerFindOne>>, TError = void>(
    id: string, options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof issuesControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof customInstance> }
    , queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get issue by ID
 */

export function useIssuesControllerFindOne<TData = Awaited<ReturnType<typeof issuesControllerFindOne>>, TError = void>(
    id: string, options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof issuesControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof customInstance> }
    , queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

    const queryOptions = getIssuesControllerFindOneQueryOptions(id, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}





/**
 * Update an existing issue by ID
 * @summary Update issue
 */
export const issuesControllerUpdate = (
    id: string,
    updateIssueDto: UpdateIssueDto,
    options?: SecondParameter<typeof customInstance>,) => {


    return customInstance<IssueResponseDto>(
        {
            url: `/issues/${id}`, method: 'PATCH',
            headers: { 'Content-Type': 'application/json', },
            data: updateIssueDto
        },
        options);
}



export const getIssuesControllerUpdateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof issuesControllerUpdate>>, TError, { id: string; data: UpdateIssueDto }, TContext>, request?: SecondParameter<typeof customInstance> }
    ): UseMutationOptions<Awaited<ReturnType<typeof issuesControllerUpdate>>, TError, { id: string; data: UpdateIssueDto }, TContext> => {

    const mutationKey = ['issuesControllerUpdate'];
    const { mutation: mutationOptions, request: requestOptions } = options ?
        options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
            options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey, }, request: undefined };




    const mutationFn: MutationFunction<Awaited<ReturnType<typeof issuesControllerUpdate>>, { id: string; data: UpdateIssueDto }> = (props) => {
        const { id, data } = props ?? {};

        return issuesControllerUpdate(id, data, requestOptions)
    }




    return { mutationFn, ...mutationOptions }
}

export type IssuesControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof issuesControllerUpdate>>>
export type IssuesControllerUpdateMutationBody = UpdateIssueDto
export type IssuesControllerUpdateMutationError = void

/**
* @summary Update issue
*/
export const useIssuesControllerUpdate = <TError = void,
    TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof issuesControllerUpdate>>, TError, { id: string; data: UpdateIssueDto }, TContext>, request?: SecondParameter<typeof customInstance> }
        , queryClient?: QueryClient): UseMutationResult<
            Awaited<ReturnType<typeof issuesControllerUpdate>>,
            TError,
            { id: string; data: UpdateIssueDto },
            TContext
        > => {

    const mutationOptions = getIssuesControllerUpdateMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
}

/**
 * Delete an issue by ID
 * @summary Delete issue
 */
export const issuesControllerDelete = (
    id: string,
    options?: SecondParameter<typeof customInstance>,) => {


    return customInstance<void>(
        {
            url: `/issues/${id}`, method: 'DELETE'
        },
        options);
}



export const getIssuesControllerDeleteMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof issuesControllerDelete>>, TError, { id: string }, TContext>, request?: SecondParameter<typeof customInstance> }
    ): UseMutationOptions<Awaited<ReturnType<typeof issuesControllerDelete>>, TError, { id: string }, TContext> => {

    const mutationKey = ['issuesControllerDelete'];
    const { mutation: mutationOptions, request: requestOptions } = options ?
        options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
            options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey, }, request: undefined };




    const mutationFn: MutationFunction<Awaited<ReturnType<typeof issuesControllerDelete>>, { id: string }> = (props) => {
        const { id } = props ?? {};

        return issuesControllerDelete(id, requestOptions)
    }




    return { mutationFn, ...mutationOptions }
}

export type IssuesControllerDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof issuesControllerDelete>>>

export type IssuesControllerDeleteMutationError = void

/**
* @summary Delete issue
*/
export const useIssuesControllerDelete = <TError = void,
    TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof issuesControllerDelete>>, TError, { id: string }, TContext>, request?: SecondParameter<typeof customInstance> }
        , queryClient?: QueryClient): UseMutationResult<
            Awaited<ReturnType<typeof issuesControllerDelete>>,
            TError,
            { id: string },
            TContext
        > => {

    const mutationOptions = getIssuesControllerDeleteMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
}
